import React, { useState, useEffect, useRef } from 'react';
import { useLocation } from 'react-router-dom'
import { IMessage, MessageType } from '../types';

enum DirectionState {
  LEFT,
  RIGHT,
  FORWARD,
  NONE
}

export default function Game() {
  const location = useLocation();
  const PACKET_INTERVAL_MS = 100;
  const WEBSOCKET_URL = GetWebSocketURL();
  const [directionState, setDirectionState] = useState<DirectionState>(DirectionState.NONE);
  const [isSendingPackets, setIsSendingPackets] = useState<boolean>(false);
  const dataChannel = useRef<RTCDataChannel>();

  // Set up WebSocket & WebRTC methods upon site loaded
  useEffect(() => {
    console.log(WEBSOCKET_URL)
    const pc = new RTCPeerConnection();
    const ws = new WebSocket(WEBSOCKET_URL, []);

    // When a new ICE candidate is generated by the peer connection, send it to the signaling server 
    pc.onicecandidate = evt => evt.candidate && ws.send(JSON.stringify(evt.candidate));

    pc.ondatachannel = (ev) => {
      dataChannel.current = ev.channel;
      dataChannel.current.onmessage = HandleDataChannelMessage;
      dataChannel.current.onopen = HandleDataChannelOpen;
      dataChannel.current.onclose = HandleDataChannelClose;
    };

    // Handle signaling server message
    ws.onmessage = async function (evt) {
      let obj = JSON.parse(evt.data);
      if (obj?.candidate) {
        pc.addIceCandidate(obj);
      }
      else if (obj?.sdp) {
        await pc.setRemoteDescription(new RTCSessionDescription(obj));
        pc.createAnswer()
          .then((answer) => pc.setLocalDescription(answer))
          .then(() => ws.send(JSON.stringify(pc.localDescription)));
      }
      else if (obj?.message) {
        let message : IMessage = obj.message;
        setIsSendingPackets(message.MessageType === MessageType.StartGame);
      }
    };
  }, [WEBSOCKET_URL])

  // Send the direction state continuously in case of packet loss
  useEffect(() => {
    if (isSendingPackets) {
      const interval = setInterval(() => {
        SendMessage(DirectionState[directionState])
      }, PACKET_INTERVAL_MS);
      return () => clearInterval(interval);
    }
  }, [directionState, isSendingPackets])

  function SendMessage(message: string) {
    if (dataChannel.current && dataChannel.current.readyState === "open") {
      dataChannel.current.send(message);
    } else {
      console.warn("Data channel is not open. Cannot send message.");
    }
  }

  function HandleDataChannelMessage(event: MessageEvent) {
    console.log("Received data channel message" + event.data)
  }

  function HandleDataChannelOpen() {
    console.log("Data channel open")
  }

  function HandleDataChannelClose() {
    console.log("Data channel closed")
    setIsSendingPackets(false);
  }

  function GetWebSocketURL() {
    let baseURL = process.env.REACT_APP_WEBSOCKET_SERVER ?? 'ws://localhost:8081'
    return `${baseURL}${location.pathname}`;
  }

  function HandleButtonUp() {
    setDirectionState(DirectionState.FORWARD);
  }

  function HandleButtonDown(direction: DirectionState) {
    setDirectionState(direction);
  }

  return (
    <div>
      <div style={{ display: "flex", justifyContent: 'center', alignItems: 'center', height: '80vh' }}>
        <button disabled={!isSendingPackets}
          onMouseDown={() => HandleButtonDown(DirectionState.LEFT)}
          onMouseUp={HandleButtonUp}
          onTouchStart={() => HandleButtonDown(DirectionState.LEFT)}
          onTouchEnd={HandleButtonUp}
          onTouchCancel={HandleButtonUp}>
          <img onContextMenu={(e) => e.preventDefault()} src="svg/left_arrow.svg" alt="Left arrow" />
        </button>
        <button disabled={!isSendingPackets} 
          onMouseDown={() => HandleButtonDown(DirectionState.RIGHT)}
          onMouseUp={HandleButtonUp}
          onTouchStart={() => HandleButtonDown(DirectionState.RIGHT)}
          onTouchEnd={HandleButtonUp}
          onTouchCancel={HandleButtonUp}>
          <img onContextMenu={(e) => e.preventDefault()} src="svg/right_arrow.svg" alt="Right arrow" />
        </button>
      </div>
    </div>
  );
};